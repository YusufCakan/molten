#!/usr/bin/python3

import os
import sys
import shutil
import os.path
import argparse
import subprocess


if shutil.which("lli") is not None:
    # MacOS
    EXT = ""
elif shutil.which("lli-7") is not None:
    # Debian
    EXT = "-7"
else:
    print("Error: unable to locate LLVM command line program \"lli\".  Please ensure that the LLVM 7 tools are included in your $PATH")
    sys.exit(-1)

RM = "rm"
BUILD = "cargo build"
COMPILE = "cargo run --"
LINK = "llvm-link" + EXT
OPT = "opt" + EXT
RUN = "lli" + EXT


def main():
    parser = argparse.ArgumentParser(prog='molten', formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Simple build script for molten programs')
    parser.add_argument('-f', '--force', action='store_true', help='Force a recompile of all files')
    parser.add_argument('-d', '--debug', action='store_true', help='Run the compiler with debugging on')
    subparsers = parser.add_subparsers()

    cmd = subparsers.add_parser("build", help="compile a single file program")
    cmd.add_argument("filename")
    cmd.set_defaults(command=command_build)

    cmd = subparsers.add_parser("run", help="compile and run a single file program")
    cmd.add_argument("filename")
    cmd.set_defaults(command=command_run)

    cmd = subparsers.add_parser("clean", help="delete all generated files")
    cmd.add_argument("directory", nargs='?', default=".")
    cmd.set_defaults(command=command_clean)

    cmd = subparsers.add_parser("cleanall", help="delete all generated files including from all subdirectories")
    cmd.add_argument("directory")
    cmd.set_defaults(command=command_cleanall)

    args = parser.parse_args()
    if 'command' not in args:
        parser.print_help()
    else:
        try:
            args.command(args)
        except Exception as e:
            sys.stderr.write("Command failed: " + str(e))


def command_build(args):
    target = os.path.splitext(args.filename)[0] + ".bc"
    flags = "-d" if args.debug else ""
    compile_and_link(target, [ "lib/libcore.ml", args.filename ], flags=flags, force=args.force)
    return target

def command_run(args):
    target = command_build(args)
    runordie(RUN + " " + target)

def command_clean(args):
    os.system("cd " + args.directory + " && " + RM + " *.ll *.dec *.bc")

def command_cleanall(args):
    for (basedir, dirnames, filenames) in os.walk(args.directory):
        for filename in filenames:
            if filename.endswith(".bc") or filename.endswith(".ll") or filename.endswith(".dec"):
                path = os.path.join(basedir, filename)
                print("Deleting " + path)
                os.unlink(path)



def compile_and_link(target, deps, flags="", force=False):
    compiled = [ ]
    main = deps.pop()
    for dep in deps:
        compiled.append(compile(dep, flags=flags+ " -l", force=force))
    compiled.append(compile(main, flags=flags, force=force))
    link(target, compiled)


def compile(filename, flags="", force=False):
    target = os.path.splitext(filename)[0] + ".ll"
    if force or not os.path.exists(target) or os.path.getmtime(filename) > os.path.getmtime(target):
        runordie(COMPILE + " -S " + flags + " " + filename)
    return target


def link(target, filenames):
    runordie(LINK + " " + " ".join(filenames) + " > " + target)


def runcmd(cmd):
    #print(cmd)
    result = subprocess.run(cmd, shell=True)
    return result.returncode

def runordie(cmd):
    #print(cmd)
    result = subprocess.run(cmd, shell=True)
    if result.returncode != 0:
        raise Exception("{} exited with code {}".format(cmd, result.returncode))



if __name__ == "__main__":
    main()

