#!/usr/bin/python3

import os
import sys
import shutil
import os.path
import argparse
import subprocess


RM = "rm"
BUILD = "cargo build"
COMPILE = "cargo run --"
LINK = "llvm-link"
OPT = "opt"
RUN = "lli"


def main():
    check_requirements()

    parser = argparse.ArgumentParser(prog='molten', formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='Simple build script for molten programs')
    parser.add_argument('-f', '--force', action='store_true', help='Force a recompile of all files')
    parser.add_argument('-d', '--debug', action='store_true', help='Run the compiler with debugging on')
    subparsers = parser.add_subparsers()

    cmd = subparsers.add_parser("build", help="compile a single file program")
    cmd.add_argument("filename")
    cmd.set_defaults(command=command_build)

    cmd = subparsers.add_parser("run", help="compile and run a single file program")
    cmd.add_argument("filename")
    cmd.set_defaults(command=command_run)

    cmd = subparsers.add_parser("clean", help="delete all generated files")
    cmd.add_argument("directory", nargs='?', default=".")
    cmd.set_defaults(command=command_clean)

    cmd = subparsers.add_parser("cleanall", help="delete all generated files including from all subdirectories")
    cmd.add_argument("directory")
    cmd.set_defaults(command=command_cleanall)

    args = parser.parse_args()
    if 'command' in args:
        args.command(args)
    else:
        parser.print_help()


def check_requirements():
    global LINK, OPT, RUN
    if shutil.which(LINK) is None:
        LINK = "llvm-link-5.0"
        OPT = "opt-5.0"
        RUN = "lli-5.0"


def command_build(args):
    target = os.path.splitext(args.filename)[0] + ".bc"
    flags = "-d" if args.debug else ""
    compile_and_link(target, [ "lib/libcore.ml", args.filename ], flags=flags, force=args.force)
    return target

def command_run(args):
    target = command_build(args)
    runordie(RUN + " " + target)

def command_clean(args):
    os.system("cd " + args.directory + " && " + RM + " *.ll *.dec *.bc")

def command_cleanall(args):
    for (basedir, dirnames, filenames) in os.walk(args.directory):
        for filename in filenames:
            if filename.endswith(".bc") or filename.endswith(".ll") or filename.endswith(".dec"):
                path = os.path.join(basedir, filename)
                print("Deleting " + path)
                os.unlink(path)



def compile_and_link(target, deps, flags="", force=False):
    compiled = [ ]
    main = deps.pop()
    for dep in deps:
        compiled.append(compile(dep, flags=flags+ " -l", force=force))
    compiled.append(compile(main, flags=flags, force=force))
    link(target, compiled)


def compile(filename, flags="", force=False):
    target = os.path.splitext(filename)[0] + ".ll"
    if force or not os.path.exists(target) or os.path.getmtime(filename) > os.path.getmtime(target):
        runordie(COMPILE + " -c " + flags + " " + filename)
    return target


def link(target, filenames):
    runordie(LINK + " " + " ".join(filenames) + " > " + target)


def runcmd(cmd):
    #print(cmd)
    result = subprocess.run(cmd, shell=True)
    return result.returncode

def runordie(cmd):
    #print(cmd)
    result = subprocess.run(cmd, shell=True)
    if result.returncode != 0:
        raise Exception("{} exited with code {}".format(cmd, result.returncode))



if __name__ == "__main__":
    main()

