
* you need to add a public/private flag to definitions, for exporting, along with a "private" attribute in IR
* update the readme

* implement return value conversion
* remove AST::Recall when you switch over to llvm2
* unable to defined a method as / MF or / C ABI
* implement try, raise

* recursive c functions don't work because it's typechecked as unknown abi, which is called as a closure
* there is a problem with typechecking Option, where in compiles it as an Option<Int> rather than Option<'item>
* I fixed the inheritence-vtable test by forcing the typevar to Int, but ideally there'd be an error when overloading.  A function with a typevar cannot be overloaded by a function with a
  specific type because a typevar function overlaps with the Int version.  It conflicts with the boxing/unboxing of generic primatives
* if, sideeffects, and while loops need bool comparison results to work correctly.  You can either force that in type checking or somehow desugar or use the comps style from match

* you could modify the forloop code to take an iterator in future
* you really need a better way of doing modules
* should vtables be dynamically allocated, or should we add a LLType::ElementOf() type or something to GetElement an aliased type

* make refinery use an object direct traversal, which can store context, which could be used to error when a mut outside a class is used, rather than putting the check in assignment
* make binding and typechecking use an object, which could help break them down a bit into smaller functions
* if you made typechecking an object like transform, and had a context, you could do extended checks of what's allowed in a C function, like exceptions (disallowed in C, but allowed in M and MF)


* strings, buffers, and all the primative types require vtables if they have methods, but there aren't vtables stored inside them.  You could make static vtable exceptions for them
* make primative types unable to inherit from, because there's no vtable
* fix lib to allow builtin classes

* can you make a check for nil before unboxing a type... and somehow return an appropriate default value?  I guess that's feasible because only primative types would be
  boxed/unboxed, although records and tuples might be an issue
* rather than coercising a non pointer type into a pointer, you can box any such types, possibly adding a vtablu of sorts in the process
  possibly containing functions and metadata for copying. You could also make buffer copying functions that take the element size and copy
  the buffer data into the boxed location.



BUGS:
* issue with calling function references store in structs or tuples... it converts them to methods incorrectly
* if there are brackets after a record literal, it will try to call it as a function: let bar = ref { a = 1, b = 2 } \n (!x).a    parses incorrectly,
  but adding a semi-colon will fix it
* prefix operations should bind closer than subatomic_operations: !x.a should be parsed as (!x).a but instead is !(x.a)
* there is still a bug with the Phi statement, in that it will return null if you don't cover all cases. there is no check for coverage
* if you only have one element in a tuple, or in a record, it parses it as a block or expression


TESTS:
* make test for function pointers, assign to local, call as ref
* test for match, if, sideeffects
* test for references, records, tuples, used in local vars, func args, return values, etc
* test for directly calling functions in records or tuples, which shouldn't add the object argument
* test for records that have different member orders are still equal
* test for static method vtable access, dynamic dispatch via that mechanism, and overloading used with resolve



* there's no way to genericly compare or print tuples or records
* make an "as" for of decl, like decl buffer_resize as resize: () -> ??
* there's probably an issue with records in that we might not take into account different orders of items... { a=1, b=2 } might not equal { b=2, a=1 }

* implement assignment of tuples and records?
* there is no way to assign to a ref

* should you unify some aspects of references and objects?  at least the codegen stuff, rather than duplicating some code
* modify resolve to return a result rather than unwrapping


* you can put a restriction on type aliases such that a type can only use type vars defined in the declaration
* you could require that classes explicitly define their type variables by name, to catch type errors.  So every method or definition in the top level of the class
  could only use explicitly declared type variables

* there was a problem with generics when using tuple pair closures, because a tuple pair was too big to coerce into an i8*. You can convert back when generics
  are fixed to adjust to their size

* there are poor error messages when deleting the "=" from a "let something = fn x => ..." both inside and outside classes.... shouldn't be doing this (actually, because of
  let without init, and the lf issue... lf fix would solve this)
* there was an error where "let ni: newint" with no initializer was causing a type error with "expected class or concrete type", but that was actually because a definition without
  an initializer is the same as "let ni: newint = nil" and nil could not be cast to a Record, which newint is a typealias of a record
* either add in the initialization of class variables, possibly limited to constant expressions only, or else raise an error if an initializer is provided
* there must be a way to fix the 'scope exceptions' (Scope::target) that we're doing to make class bodies work... pass in an argument to all scoped functions?  or use scopemap and scope ids?

* you might not be making sure that non-closure functions don't access variables outside their scope (methods are never closures)
* make sure that you don't overload different types of functions (closures, functions, and methods must all be the same type to allow overloading)
* should you make mutable modifiers more strict, like rust?
* should compare use a trait/typeclass? that would have to come later


* improve storing of file info in the Pos structs (maybe rename to Span?)
* change parser to take session argument or something so it can record the file info, and maybe do other advanced things
* should you add session to refinery and process imports there
* one thing i'm seeing a lot of now is stuff like classspec.ident.name... can we prevent so many levels deep?
* do you need a BuiltinDef type? a GlobalVarDef type?
* add the .set_id() functions to simpliy ast builders

* it might also make it easier/generic to allow compiling to object files?  So no linking, but it would do optimization and object file output
* how does rust do "use" if there is a circular dependency?
* put intermediate files somewhere else, at least as controlled by the molten script, so as not to clutter source directories

* there's still a problem with typevars not resolving fully, where a function that should return a concrete returns a free typevar.... (recursion or forward definition)


* implement enums
* add patterns and matching of patterns
* add a spread operator for records
* add an iterator type
* get llvm closures working
* implement exceptions
* implement garbage collection
* add compiler directives?
* use customized visitors throughout

* issue with separator/lf not working when two expressions are on the same line (it should produce a parse error)
* better support for generics; right now it just forces everything to/from a pointer type
* fill in string and list type functions, and finish hashmap (rename to dict?)




* should you make the top level module functions be closures, instead of using global vars
* if even the global/module scope was a closure, then you could make a module be equivallent to an implicit function that is called when the module is imported, which could have the name of the
  module; so a module called main would become the main() function


* should exports also list all the modules that the file imports, so that class definitions in other imports can be found, if needed for arguments
* should you add access modifiers to classes, and maybe functions; public, private, protected
* should you fix scope resolution to also work on objects, so that you can have static methods from the object without explicitly referencing its type
* should you remove the Nil type?
* should you add break/continue statements for loops
* should you add a return statement?  It's not functional, but it's practial
* should you change Real to Float?  also should you change them to lower case names, which is in line with sml, ocmal, f#
* should you allow keyword arguments in invoke; foo(a=10, b=20)
* should you allow arguments with a default value to be omitted from a function call?, that would require a bunch of changes to typechecking
* should local variables be allowed to be mutable...
* should you require an override keyword when masking definitions in lower scopes? like class definitions
* should you add macros and expandable forms (like lisp)

* is it even possible to add a special "constrained" type, which has &AST that must type check correctly in order to match (checks done in check_type)
* you might need to integrate type restrictions which have to get resolved later; like 'a where 'a is object with add(Int) method; not sure how you could be so specific without complexity
* what if you generalize overloaded types, such that they're checked in check_type, and options are eliminated, or resolved to one type over the course of checking
* if you make ops methods, then everything has to be type annotated, with the type system as it is; you'd need constrained types, or multiple paths, or bidirectional or something
  make typed functions for all math operations, with the inlinealways attribute, if you decide to make operators methods
* what if you have a 'context' passed to the node visitors that would allow "if" to know if its' return is used or not, and so whether typechecking must match



EXAMPLE PROGRAM IDEAS:

* hash table
* regex matcher


