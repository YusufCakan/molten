
* could make new element for method invoke: AST::InvokeMethod(name, args, ...)
* could add an object to invoke: AST::Invoke(object, fexpr, args, ...)
* could use a special element for indirection: AST::FirstArg;  AST::Invoke(AST::Accessor(AST::FirstArg, "foo"), vec!(object, arg1, arg2, ...), ...)
* could change AST::Accessor into AST::Resolver during typecheck, but this would have be done after type checking... because the type might be a variable until then


* change the debug prints to overwrite Debug formatting for scopes
* fix scope resolution to also work on objects, so that you can have static methods...
* fix constructors, perhaps by making all methods called new() allocate before the method is called?
* make typed functions for all math operations, with the inlinealways attribute, if you decide to make operators methods


* refactor heavily
* add error returns instead of panics
* add operator overloading; issue with type system as a result of making operators methods
* add module initialization functions and sort out issue with duplicate main() functions
* implement lists in compiled code
* add or expand string support
* implement exceptions
* implement garbage collection
* get llvm closures working



* is it even possible to add a special "constrained" type, which has &AST that must type check correctly in order to match (checks done in check_type)
* if you make ops methods, then everything has to be type annotated, with the type system as it is; you'd need constrained types, or multiple paths, or bidirectional or something
* you might need to integrate type restrictions which have to get resolved later; like 'a where 'a is object with add(Int) method; not sure how you could be so specific without complexity
* what if you generalize overloaded types, such that they're checked in check_type, and options are eliminated, or resolved to one type over the course of checking
* if you were to support the generation of functions with more than one type/variable types, you'd need to collect all invokation types for each function during collect
* if you had a tuple type, you could use a typevar to represent a tuple of the arguments to a function: Type::Function(Type::Variable(..), Type::Variable(..)) or 'a -> 'b where 'a = ('c, 'd, 'e)



* should import indexes also list all the modules that the file imports, so that class definitions in other imports can be found, if needed for arguments

* should class bodies use different rules than blocks, with different definition statements, like "def foo: Int", such that a value isn't required for members
* should classes be values, added to the name space, or should they only be defined as types; should types be first class or not?
* should you allow keyword arguments in invoke; foo(a=10, b=20)
* should you allow arguments with a default value to be omitted from a function call?, that would require a bunch of changes to typechecking



TYPE CHECKING:

* remove unused typechecking vars somehow...
* implement type definition ast element


PARSER:

* issue with separator/lf not working when two expressions are on the same line (it should produce a parse error)
* add line and column numbers to error reporting
* add error returning so multiple errors can be caught at once
* make nestable comments


FEATURES:

* add dicts syntax
* add macros and expandable forms (like lisp)
* what about type functions to build/cast to specific C/LLVM types, like i32, i8, etc

