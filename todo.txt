
* refactor code that uses num_funcdefs

* should you store ClassSpec as Type::Object instead, given that we use it in many places where Pos necessarily make sense
* one thing i'm seeing a lot of now is stuff like classspec.ident.name... can we prevent so many levels deep?

* how can you use all the new things to make closures...
* you could check during binding if an identifier is a closure context ref, and bind the ref there
* you might not be making sure that non-closure functions don't access variables outside their scope (methods are never closures)
* make sure that you don't overload different types of functions (closures, functions, and methods must all be the same type to allow overloading)

* do you need a BuiltinDef type?
* do you need a GlobalVarDef type?  or a ConstDef or FieldDef/PropertyDef/etc
* remove declare typevars if possible??

* there must be a way to fix the 'scope exceptions' (Scope::target) that we're doing to make class bodies work...
* but actually... what if you had an argument that you sent to all the scoped functions that select the namespace?  This might be a refactor for later, once scopes only store def ids
* add some helpful things to the AST::make_* functions, maybe we'd need a different name format for those?
* add the .set_id() functions to simpliy ast builders

* eventually we want to make a visitor
* improve storing of files and file data in the Pos structs (maybe rename to Span?); pass session to parsers
* change parser to take session argument or something so it can record the file info, and maybe do other advanced things
* remove extraneous Pos's with Ident/Arguments?

* make common error printer, with fancy colours
* there are poor error messages when deleting the "=" from a "let something = fn x => ..." both inside and outside classes.... shouldn't be doing this

* it might also make it easier/generic to allow compiling to object files?  So no linking, but it would do optimization and object file output
* how does rust do "use" if there is a circular dependency?

* add ast element like Struct... which does the same as class build type, but without the vtable stuff, and we can bypass some of the complexity...
  but!!!! could we also/instead factor out the vtables somehow... so that it's more modular/selectable


* there's still a problem with typevars not resolving fully, where a function that should return a concrete returns a free typevar.... (recursion or forward definition)
* either add in the initialization of class variables, possibly limited to constant expressions only, or else raise an error if an initializer is provided
* fix the parser issues where you need nil to make it work.... i think parser parsing ";" into noop/nil might work, if i can get the parser working

* add an iterator type that gets used in for loops; might need vtables for that

* put intermediate files somewhere else, at least as controlled by the molten script, so as not to clutter source directories

* add compiler directives?
* get llvm closures working
* implement exceptions
* implement garbage collection
* add patterns and matching of patterns
* implement type definition ast element (enum type?)

* better support for generics; right now it just forces everything to/from a pointer type
* fill in string and list type functions, and finish hashmap (rename to dict?)




* if even the global/module scope was a closure, then you could make a module be equivallent to an implicit function that is called when the module is imported, which could have the name of the
  module; so a module called main would become the main() function
* what if you have a 'context' passed to the node visitors that would allow "if" to know if its' return is used or not, and so whether typechecking must match
* if you make ops methods, then everything has to be type annotated, with the type system as it is; you'd need constrained types, or multiple paths, or bidirectional or something
  make typed functions for all math operations, with the inlinealways attribute, if you decide to make operators methods

* is it even possible to add a special "constrained" type, which has &AST that must type check correctly in order to match (checks done in check_type)
* you might need to integrate type restrictions which have to get resolved later; like 'a where 'a is object with add(Int) method; not sure how you could be so specific without complexity
* what if you generalize overloaded types, such that they're checked in check_type, and options are eliminated, or resolved to one type over the course of checking


* should you add access modifiers to classes, and maybe functions; public, private, protected
* should you add break/continue statements for loops
* should you change Real to Float?  also should you change them to lower case names, which is in line with sml, ocmal, f#
* should you allow keyword arguments in invoke; foo(a=10, b=20)
* should you allow arguments with a default value to be omitted from a function call?, that would require a bunch of changes to typechecking
* should you fix scope resolution to also work on objects, so that you can have static methods from the object without explicitly referencing its type
* should exports also list all the modules that the file imports, so that class definitions in other imports can be found, if needed for arguments
* should variables be writable... maybe only with compiler directive, or only without one; if so, add a const expression
* should you add let mut or def to class bodies so as not to conflict with 'let' as immutable outside of class bodies
* should you add a return statement?  It's not functional, but it's practial
* should you require an override keyword when masking definitions in lower scopes? like class definitions



PARSER:

* issue with separator/lf not working when two expressions are on the same line (it should produce a parse error)
* make nestable comments


FEATURES:

* add dicts syntax
* add macros and expandable forms (like lisp)


EXAMPLE PROGRAMS:

* hash table
* regex matcher


