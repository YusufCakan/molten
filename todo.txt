
* fix constructors, perhaps by making all methods called new() allocate before the method is called?

* add a const expression
* remove instances of List()
* should you make interpreter harder to activate?  Should no -c do a compile/link/run step instead of interpret?
* should you add a char type?

* for setitem/getitem, you need to know whether this is assigning to the result, or recalling from the result, so you don't know which to check for.  It shouldn't
  be required to overload both set and get in order to satisfy a requirement... I suppose another way to do this would be using a trait/interface/protocol/whatever for "Indexable"
  instead of just checking for the method, which is more duck typing i think... not that I have anything against that, but it's a more dynamically typed sort of thing

* change the debug prints to overwrite Debug formatting for scopes
* fix scope resolution to also work on objects, so that you can have static methods...
* make typed functions for all math operations, with the inlinealways attribute, if you decide to make operators methods
* there is a problem with some type inference, fn x => x() + 1; it might be fixed if the type of x can be resolved(), but that doesn't happen currently.  In some places it makes more trouble

* add generation of functions with typevars, as if overloaded...
* you kind of need a macro/compile-time function to call a list generic function and cast the element to a void pointer, to be stored in the list...


* add error returns instead of panics
* add operator overloading; issue with type system as a result of making operators methods
* sort out issue with duplicate main() functions
* implement lists in compiled code
* add or expand string support
* implement exceptions
* implement garbage collection
* get llvm closures working
* implement type definition ast element (enum type?)



* if you added decls as AST elements, then you could possibly declare external functions in localized scopes so they aren't accessible to other code
* is it even possible to add a special "constrained" type, which has &AST that must type check correctly in order to match (checks done in check_type)
* if you make ops methods, then everything has to be type annotated, with the type system as it is; you'd need constrained types, or multiple paths, or bidirectional or something
* you might need to integrate type restrictions which have to get resolved later; like 'a where 'a is object with add(Int) method; not sure how you could be so specific without complexity
* what if you generalize overloaded types, such that they're checked in check_type, and options are eliminated, or resolved to one type over the course of checking
* if you were to support the generation of functions with more than one type/variable types, you'd need to collect all invokation types for each function during collect
* if you had a tuple type, you could use a typevar to represent a tuple of the arguments to a function: Type::Function(Type::Variable(..), Type::Variable(..)) or 'a -> 'b where 'a = ('c, 'd, 'e)
* if you define a class in a deeper scope than its previous definition, it will mask it; which applies to fundamental types as well.  This is actually helpful atm for making libcore, but
  it might not be desirable.  Perhaps you could use a keyword like 'override' to silence an error or warning when masking



* should import indexes also list all the modules that the file imports, so that class definitions in other imports can be found, if needed for arguments

* should class bodies use different rules than blocks, with different definition statements, like "def foo: Int", such that a value isn't required for members
* should classes be values, added to the name space, or should they only be defined as types; should types be first class or not?
* should you allow keyword arguments in invoke; foo(a=10, b=20)
* should you allow arguments with a default value to be omitted from a function call?, that would require a bunch of changes to typechecking



TYPE CHECKING:

* remove unused typechecking vars somehow...


PARSER:

* issue with separator/lf not working when two expressions are on the same line (it should produce a parse error)
* add line and column numbers to error reporting
* add error returning so multiple errors can be caught at once
* make nestable comments


FEATURES:

* add dicts syntax
* add macros and expandable forms (like lisp)

