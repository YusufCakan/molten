
* fix the issues where you need nil and shit to make it work.... i think parser parsing ";" into noop/nil might work
* should you change to < > format instead of [ ] for type parameters, in the name of consistency?
* should variables be writable... this is more about breaking with functional traditions
* add a const expression

* what about the value initializations in the class...
* should class bodies use different rules than blocks, with different definition statements, like "def foo: Int", such that a value isn't required for members


* issue with self and super type defs; they don't contain the type info; maybe add an aliasing type?
* what if you a 'context' passed to the node visitors that would allow "if" to know if its' return is used or not, and so whether typechecking must match

* you might have a potentially big issue with duplicate type variables, specifically with map_typevars; it could mistake an undeclared
  function's typevar with an already defined typevar if they have the same name
* could you pass an extra argument to check_types_node() with an expected type, so it can use that if needed, rather than creating a typevar
* make nil work without using a typevar?  Or just eliminate unnecessary typevars
* if you had a tuple type, you could use a typevar to represent a tuple of the arguments to a function: Type::Function(Type::Variable(..), Type::Variable(..)) or 'a -> 'b where 'a = ('c, 'd, 'e)
* add an iterator type that gets used in for loops; might need vtables for that


* should you convert class name/types tuples into types
* match only works with integers... maybe call ==, but it would have to mangle correctly
* there might be trouble with the argument cast in invoke compiling


* fill in string and list type functions
* add line and column numbers to error reporting
* add error returning so multiple errors can be caught at once
* add better support for generics; right now it just forces everything to/from a pointer type

* add vtables for classes
* implement exceptions
* implement garbage collection
* get llvm closures working
* implement type definition ast element (enum type?)




* if you make ops methods, then everything has to be type annotated, with the type system as it is; you'd need constrained types, or multiple paths, or bidirectional or something
* make typed functions for all math operations, with the inlinealways attribute, if you decide to make operators methods
* is it even possible to add a special "constrained" type, which has &AST that must type check correctly in order to match (checks done in check_type)
* you might need to integrate type restrictions which have to get resolved later; like 'a where 'a is object with add(Int) method; not sure how you could be so specific without complexity
* what if you generalize overloaded types, such that they're checked in check_type, and options are eliminated, or resolved to one type over the course of checking
* there is a problem with some type inference, fn x => x() + 1; it might be fixed if the type of x can be resolve_type'd(), but that doesn't happen currently.  In some places it makes more trouble


* should you change the return type annotation format to : from ->?  fn foobar(): String { } instead of fn foobar() -> String { }
* should you add a return statement?  It's not functional, but it's practial
* should you fix scope resolution to also work on objects, so that you can have static methods???
* should import indexes also list all the modules that the file imports, so that class definitions in other imports can be found, if needed for arguments
* should you require an override keyword when masking definitions in lower scopes? like class definitions
* should you allow keyword arguments in invoke; foo(a=10, b=20)
* should you allow arguments with a default value to be omitted from a function call?, that would require a bunch of changes to typechecking



TYPE CHECKING:

* remove unused typechecking vars somehow...


PARSER:

* issue with separator/lf not working when two expressions are on the same line (it should produce a parse error)
* make nestable comments


FEATURES:

* add dicts syntax
* add macros and expandable forms (like lisp)


EXAMPLE PROGRAMS:

* hash table
* regex matcher


